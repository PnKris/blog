---
comments: true
title: Why Go and not Rust?
key: 2019110701
picture_frame: shadow
tags:
  - Go
---

> Loris Cro의 블로그 포스트(https://kristoff.it/blog/why-go-and-not-rust/) 옮김

<!--more-->

> 본문은 원저자에게 허가를 받고 번역한 글입니다.

<br>

당신이 Go를 메인 언어로 사용하는 개발자라고 상상해봅시다.
개발자 모임에 참석하고, 사람들과 의견을 나누다, 얼마 전 본인이 무엇인가 할 수 있는 작은 툴을 Go를 이용해 개발했다는 사실을 알려주기로 합니다.
당신은 그 툴이 Go로 만들어졌으니 빠르다는 등, 싱글 바이너리라는 등의 이야기를 합니다.
모임의 사람들은 당신의 이야기를 즐겁게 듣고 당신도 뿌듯함을 느끼기 시작합니다.
하지만 스산한 바람과 함께 누군가 당신 뒤에 다가와 이렇게 말합니다.

**"Why Go and not Rust?"**

들떴던 기분이 약간 가라앉습니다. 뭐, 간단하게 자신이 잘 사용할 수 있는 언어가 Go라서 이용한 것이다, 라고 말할 수도 있겠지만 만족스러운 대답이 아니겠죠.
당신은 자신의 툴이 얼마나 빠른지 자신만만하게 이야기하고 있었고, 질문을 건넸던 낯선이가 Rust가 Go에 비해 가진 장점을 이용해 간단하게 반박해버립니다.

당신은 기분이 나빠집니다. 애초에 왜 Go를 공부하기로 선택하셨던지? 당신은 Go가 빠르며, 동시성 제어가 뛰어난 언어라고 들었기 때문입니다.
그리고 이제 Rust가 화제에 오르더니 모든 사람들이 Rust가 Go보다 얼마나 뛰어난지에 대해 이야기하기 시작합니다.
조금 전까지 Go의 성능에 흥미로워하던 그들의 모습은 온데간데 없습니다. 이 사람들이 연기를 한 것일까요.
완벽한 프로그래밍 언어는 존재하지 않다는 것을 당신도 알고 있습니다. 개발자는 잘못된 선택을 하고 *기술적 막다른 길(Technological cul de sac)*에 얼마든지 빠질 수 있습니다.
그리고 몇 년 전의 당신은 여러 언어 중 Go를 택했고 "Why *that* and not Go?"라고 말하는 그룹에 합류했었죠.

<br>

위 이야기는 실화가 아닙니다. 하지만 Rust 팬덤 사이에는 타인을 구원하고자 Rust를 집요하게 어필하는, 과도하게 흥분한 몇몇 회원이 있다는 것은 많이들 알고 있는 사실입니다.
그것은 Rust의 잘못이 아닙니다. 성공적인 프로젝트는 언제나 삐뚫어진 팔로워를 동반합니다. 이는 피할 수 없으며 그 주변 모든 사람들이 이 Rust 광신도와 대면해야하며,
특히 Go 개발자들은 Go와 Rust의 messaging 유사성으로 비교 대상으로 더 자주 언급됩니다.

**Go는 빠르지만, Rust는 더 빠릅니다.**

**Go는 효율적인 Garbage Collector가 있지만, Rust는 Static Memory Management를 합니다.**

**Go는 interface를 가지지만, Rust는 trait이 있고 zero-cost abstraction이 가능합니다.**

Go 개발자가 보기에는 약간 사기당한 기분이 들 수도 있습니다. 반면에, Python 개발자들은 이런 Rust에 장점에 전혀 흔들리지 않습니다.
그들은 Python이 많은 방면에서 느리고 비효율적으로 작동하는 언어임을 압니다. 하지만 Python의 역할은 "쉽게 코딩하고 퍼포먼스가 중요한 영역은 C를 이용하는 것"(make the code easy to write and offload to C when performance matters)임을 인지하고 있죠.

<br>

*Go는 어떨까요?*

<br>

# Go는 서비스 개발에 좋습니다.

Go는 구글이, 구글의 문제를 해결하기 위해 만든 언어입니다. 대부분은 네트워크에 연결된 서비스들을 수반했죠. Go의 동시성 모델은 복수의 독립적인 리퀘스트를 처리해야하는 서버사이드 어플리케이션에서 쓰이기 적절한 구조로 되어있습니다.
복잡한 result-passing scheme보다 말이죠. 이것이 *await*이 아닌 *go*가 주어진 이유입니다.

Go는 HTTP와 그 관련 프로토콜에 대한 지원이 뛰어나며, 잘 작동하는 웹 서비스를 빠르게 구현할 수 있습니다.
제 경험상으로는 컴포넌트 간의 인터페이스를 명쾌하게 정의하여 사용해야 할 때 Go는 관용적인 Node.js의 좋은 대체제가 되었습니다.

또한, Go는 동시성과 퍼포먼스 문제의 진단이 효과적이며, cross-comilation은 어느 플랫폼이든 배포를 쉽게 할 수 있습니다.

# Go는 서비스 개발에 좋습니다.


